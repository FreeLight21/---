## 八股文

### 01、线程池

1. 线程池的好处：-》池化技术
   * 减少资源的浪费，可以重复利用已有的线程，不用频繁的创建线程和销毁线程造成消耗
   * 提高响应速度，当任务到达时，任务不用等候线程的创建，就可以立即执行
   * 提高客观理性：线程是有限的资源，频繁的创建线程会影响到系统的稳定性，线程池可以分配，管理，调优，监控线程。

2. Executor框架

   * 比Thread.start()启动线程更方便，执行任务需实现Runnable 和 Callable接口

   * ThreadPoolExecutor, ScheduledThreadExcutor-->ExecutorService->Executor(核心接口)

   * Future接口或者Future接口的实现类FutureTask,可以返回任务执行的结果。

   * 阿里巴巴推荐使用<mark>ThreadPoolExecutor</mark>

     ```java
     ThreadPoolExecutor executor = new ThreadPoolExecutor();
     1.CorePoolSize,核心线程池数量
     2.MaxmumSize,最大线程池数量，核心线程已经满了， 任务队列也装不下任务了，此时就会使用最大线程池数量。
     3.keepAliveTime, 当线程数大于核心线程数的时候，此时没有任务提交，核心线程之外的空闲线程在keepAlive时间之后才会被销毁。
     4.ThreadFactory, 默认，用来创建线程
     5.RejectExecutionHandler拒绝策略，abortPolicy，抛出异常，RejectExecutorException,     
     ```

   * ThreadPoolExecutor的构造函数有好几个，这是最长的参数的一个构造器，其他都是它的变种。
   
3. <font color = green>创建线程的两种方式：</font>

   * ThreadPoolExecutor构造函数，推荐

   * 使用工具类Executors

     * FixedThreadPool
     * singlePoolExecutor
     * cachedThreadPool

     >这三种线程池的底层都是使用的ThreadPoolExecutor创建而成，FixedThreadPool,以及singlePoolExecutor的workingQueue使用的是无界队列，Intger.MAX_VALUE,会造成OOM

### 02、 CAS(CompareAndSwap)

   1. 无锁机制，首先从内存区中位置获得值的大小，和我们预期expect的值比较，如果没有发生了改变，就update更新为新值，将新值写入到内存区当中。如果发生改变了，两者值不相等，就反复重试，通过这种机制保证原子性。
   2. 锁与共享变量
      * 乐观锁，认为线程操作共享变量的过程中，没有其他的线程会修改共享变量的值，对结果持乐观态度。CAS就是乐观锁，无锁，
      * 悲观锁， synchronized，同步机制，就是悲观的，认为线程冲突一定会发生，所以在同一时刻，只能允许一个线程占有资源。
   3. CAS无锁，violatile关键字，让共享变量可见，这样其他的线程也能看到共享变量的实时变化。
   4. CAS缺陷：ABA问题，将内存位置的值修改为B，然后再修改为A，整个过程，值没有变化，而实际上中间已经修改了一次，--》加上版本号：1A2B3A。

   ### 03、Java虚拟机

   1. JDK->JRE->JVM三者的关系，前者包含后者

   2. java虚拟机的结构：classfiles-》classloader类加载子系统-》运行时数据区running data area-》执行引擎（解释器，即时编译器，垃圾回收器）-》本地方法接口

   3. 类加载器： 加载-链接-初始化三步，负责字节码的加载工作

      * 加载阶段：引导类加载，扩展类加载，系统类加载器
      * 链接阶段：验证verify，准备prepare，解析resolve

   4. 解释器、即时编译器JIT,

   5. 比较流行的三个虚拟机：hotspotVM, JRockit, J9, JRockit是号称世界上最快的虚拟机。

   6. 双亲委派机制：加载请求到达类加载器的时候，不会自己先去加载，首先向上委托给父类的类加载，父类加载器处理不了，再有子类加载器处理。系统类加载器向上委托-》扩展类加载器-》引导类加载器

   7. 栈帧：局部变量表，操作栈，方法返回地址，动态链接

   8. 堆： 新生代（eden,s0,s1）-》老年代,MetaSpace元数据区包含常量池，方法元信息，类信息

   9. 为什么要有双亲委派机制：当自定义一个String.class类，在这种机制下 bootstrap.classloader已经提前加载过这些类了，保护程序安全，防止核心 API被纂改。

   10. verify,验证：主要使字节码，文件格式，元数据验证-》prepare准备，为类变量分配内存空间，并默认初始化 。-》resolve解析，将符合引用变为直接引用的过程，<mark>符合引用：用一组符合来描述所引用的目标。 </mark>直接引用：直接指向目标的指针，定位到目标的句柄。

   11. 程序计数器：用来保存下一条字节码指令的地址，内存空间很小的一块地址，是运行速度最快的存储区域。CPU要来回的不断切换线程，切换回来之后，就是程序计数器来明确吓一跳要执行的指令。

   12. 虚拟机栈：本地变量表(方法的局部变量)、操作数栈，方法返回地址，链接地址；栈是不存在垃圾回收的。 虚拟机栈的大小是动态的，也可以是固定不变的。它的大小直接决定了函数调用的最大可达深度。

       >通过参数-Xss来调整最大栈空间

   13. 本地变量表，内部是一个index：0~n-1的数组，最小单位是slot, 32位以下的数据类型是占一个slot, 64位的数据类型占两个slot(例如：long、double); slot可以重复利用，当局部变量的过了变量作用域，栈为了节省内存空间，会重复利用这些过期局部变量的slot.

   14. 类变量初始有两次时机：1.linking，prepare阶段为类变量分配空间并赋默认值。2. init初始化阶段，为类变量赋予程序员定义的值。而局部变量是不存在系统初始化的，这意味着局部变量则必须人为的初始化。

   15. 操作数栈：用来保存计算过程中的中间结果。

   ![image-20200706094109629](D:/Study Document/Java Learning/Java Notes/JVM/LearningNotes/JVM/1_内存与垃圾回收篇/5_虚拟机栈/images/image-20200706094109629.png)

   bipush，压栈到操作数栈中，istore_1,将操作数栈顶部的元素15，存储到局部变量表中索引为1的位置，局部变量表索引为0的位置保存this的指针。

   16. 动态链接：包含的是指向运行时常量池的引用，它的内存地址。运行时常量池包含了符合引用和字面量，动态链接的作用就是将符合引号转换为调用方法的直接引用。

   17. 动态类型or静态类型语言：<mark>类型检查是在编译期还是运行期</mark>, 

   18. 链接：静态链接or动态链接

       * 静态链接：在编译期间就能够确定方法的版本，而且运行期间保持不变，这种情况下直接调用方法的符合引用转换为直接引用，对应的是早期绑定。
       * 动态链接：在编译期间被调用的方法无法确定下来，只能在运行期间，才可以将用方法的符合引用转换为直接引用，晚期绑定。

   19. 方法返回值：returnvalue, 保存的是调用了该方法B的上一级方法A的pc寄存器的值，将改地址交给执行引擎，就能执行A方法的下一条指令。<mark>当方法正常退出的时候，返回地址是调用者的pc寄存器的值；而通过异常退出的，返回地址是要通过异常表来确定</mark>

   20. 虚拟机栈：管理java方法、本地方法栈：用来管理本地方法的调用。

   21. 一个JVM实例只存在一个堆内存，且是共享的。-Xms（最小内存）-Xmx(最大内存)， 在这里可以划分出TLAB（Thread Local Allocation Buffer）线程私有的缓冲区。

   22. 堆：几乎java所有的对象的实例以及数组都会在运行时在这里划分。这里垃圾gc最主要的区域。

       >java7: 堆分为：新生代--》Eden ,Suriror(s0,s1)，老年代，永久代（方法区）
       >
       >java8: 堆分为：新生代，老年代，元空间
       >
       >为什么要将永久代变为元空间？
       >
       >* 为永久代设置空间大小很难确定。某些场景下，如果动态类加载过多，容易产生Perm区的oom.
       >* 对永久代调优时很困难的

   23. Young新生代：eden, from , to 的比例是8：1：1， 新生代：老年代的比例--》1：2； 

   24. 概括下堆中对象的分配过程：

       >新建对象首先Eden,当eden满之后，就会触发minor GC ,同时将eden园区中幸存的对象转移到s0区， 然后eden区就能接着存放新建的对象，如果再次触发垃圾回收，so区的幸存对象会被转移到s1区，接着再次进行垃圾回收，s1->s0区，当满足默认的15次GC转移之后，就会就如养老区，当养老区内存不足，就会触发Major GC，当剩余的空间仍然无法保存下对象，就会OOM异常

   25. eden满了之后会触发minor gc， 但是suriror满了之后，不会触发minor gc.

   26. 从内存模型的角度，而非垃圾回收的角度，可以将Eden区分为多个线程的TLAB，每一个线程一个TLAB。

   27. 如何判断对象是否死亡？

       * 可达性分析
       * 引用计数法：无法解决循环引用的问题，每个地方引用了，引用就加1，引用失效了就减1，直到等于0，没有引用存在了。

   28. 方法区保存的内容：类型信息，域信息，方法信息， JIT代码缓存，静态变量，运行时常量池（字符串常量池）

   29. 运行时常量池（方法引用，数量值，类引用，符合引用、字段引用），字符串常量池，静态变量（前两者在jdk7之后之后，搬到了堆中），JDK8,方法区变成了本地内存中的元空间。

   30. StringTable为什么要调整位置到堆中。永久代的回收效率不高，Full GC只有在老年代和永久代空间不足的时候才触发。而我们在开发过程中有大量的字符串被创建，回收效率低，会导致老年代内存不足，OOM。

   31. <mark>创建对象的几种方式：1.new, 2.Class.newInstance(), 3, clone()方法。4.反序列化。</mark>

   32. <mark>创建对象的过程步骤：</mark>

       * 判断对象的类是否加载、链接、初始化
       * 为对象分配内存空间
       * 处理并发安全问题
       * 初始化分配到的空间
       * 设置对象的对象头
       * 执行init方法进行初始化
       * 对象头：运行时元数据(哈希值、GC分代年龄...)、类型指针(方法区中存在的类元信息)。

   33. <font color=green>对象的访问两种方式：</font>

       * 句柄访问：本地变量表中保存句柄池在堆中的地址，堆中有个句柄池：1.对象实例数据的指针--》堆中，2.对象类型的数据指针——》方法区

         ![image-20200709164342002](D:\Study Document\Java Learning\Java Notes\JVM\LearningNotes\JVM\1_内存与垃圾回收篇\10_对象实例化内存布局与访问定位\images\image-20200709164342002.png)

       * 直接指针：本地变量表中保存时对象实例在堆中的地址，堆中的对象实例包含对象类型的数据指针，这个指针指向方法区。

         ![image-20200709164350466](D:\Study Document\Java Learning\Java Notes\JVM\LearningNotes\JVM\1_内存与垃圾回收篇\10_对象实例化内存布局与访问定位\images\image-20200709164350466.png)

   34. 执行引擎：1、解释器(将字节码指令逐条解释成机器相关的指令执行) 2、JIT编译器(直接将源代码编译成机器机器相关的指令)， 3、垃圾回收器。 java是一门半编译半解释型的语言。

   35. 既然有了JIT编译器，为什么还要有解释器？--》这是因为当程序启动后，解释器可以立即执行，省去编译时间，立即运行。但是代码编译成本地代码，需要一段时间，但是一旦编译完成后，执行效率非常高。

   36. new String都是在堆上创建字符串对象，<mark>当调用intern方法时，编译器会将字符串添加到常量池StringTable维护</mark>，并返回改常量的引用。intern()方法可以用来判断字符是否在字符常量池中存在。在调用intern()方法的时，如果 常量池中已经包含了由equals(object)方法确定的与该字符串对象相同的字符串，就返回池中的字符串，否则，该字符串对象会被添加到池中，并返回对该字符串的引用。

   37. String Pool是一个固定大小的Hashtable, 默认大小长度是1009.

   38. 字符串的拼接：s1+s2的底层是，new StringBuilder()对象，s.append(s1), s.append(s2),  s.toString()-》类似于new String("ab")

   39. <mark>intern关键字：</mark>s.intern():  JDK6,JDK7的使用是不同的：

       * JDK6：如果字符串常量池没有这个对象会尝试放入池中
         * 如果串池中存在该字符串对象，则返回串池中该对象的地址
         * 如果串池中不存在该字符串对象，会把此**对象复制一份**，放入串池，并返回串池中该对象的引用地址。
       * JDK7：
         * 如果串池中存在该字符串对象，则返回串池中该对象的地址
         * 如果不存在，会将对象在堆中的引用地址复制一份，放入串池中，并返回串池中该副本的引用地址。

   40. 垃圾：在程序运行期间，没有任何指针(引用)指向的对象。

   41. 怎么判断一个对象已经死亡：

       * 引用计算法->如果存在循环引用，A引用了B， B中又引用了A，这就是循环引用，这会导致内存泄露。
       * 可达性分析算法(根搜索算法)，<mark>使用该算法后，内存中的存活对象会被根对象集合直接或间接连接着，搜索走过的路径被成为引用链</mark>， 如果对象没有任何引用链连接，说明该对象已经死亡，可以标记为垃圾对象。

   42. JVM常见的三种垃圾回收算法：

       * 标记-清除算法

         >分为两个步骤：1、标记： Collector从根结点开始遍历，标记所有被引用的对象，在对象的header进行标记，记录为可达对象，标记的是可达对象，不是垃圾。 2、清除： 遍历整个堆内存，如果发现某个对象的对象头没有被标记为可达对象，则该对象就是垃圾，将其回收。

         * 垃圾清除：不是真正意义上的清除，可是将需要清除对象的地址维护在一个空闲的地址列表中，当新对象需要加载的时候，判断垃圾的位置空间是否够，如果够，就存放在原有的地址。

       * 复制算法

         >将活着的内存空间分为两部分，每次只使用其中的一块，在垃圾回收阶段，将存活对象复制到未被使用的另一块内存空间中，之后清除之前使用的内存空间中所有的对象，交换两个内存的角色，最后完成垃圾回收。

         * 在新生代中，eden, s0,s1区就使用这种复制算法，来完成垃圾回收，当伊甸园区中的对象已经满了，就会触发垃圾回收，将垃圾对象回收，存活对象会从eden,复制到from区中， 同时维护GC年龄计数器。
         * 主要是针对新生代，因为新生代垃圾对象比较多，存活对象比较少，复制成本不大。

       * 标记-压缩算法

         * 在老年代中，常见的情况是：大部分对象都是存活对象，如果使用复制算法，复制的成本很高。

         >标记压缩算法相当于标记-清除算法执行 完成后，在进行一次内存碎片的整理。第一阶段：和标记清除算法一样，标记所有的被引用对象， 第二阶段，将所有的存活对象压缩到内存的一端，按顺序排放，之后整理清除边界外所有的内存空间。

   43. 强引用，软引用，弱引用，虚引用有什么区别？

       * 这4种引用的强度，依次逐渐减弱。
       * 强引用：程序代码中普遍存在的引用赋值，只要强引用关系还存在，垃圾回收器就永远不会回收被引用的对象。
       * 软引用：系统发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。
       * 弱引用：<mark>当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</mark>
       * 虚引用：为对象设置一个虚引用关联的惟一目的是：这个对象被收集器回收时能收到一个系统通知。一个对象的虚引用存在与否，完全不决定对象的声明周期。

   44. 垃圾收集器分类：

       * 按线程数分： 串行垃圾回收器、并行垃圾回收器(允许多个CPU同时执行垃圾回收，提升了应用的吞吐量，不过并行回收和串行回收一样，采用独占式，使用”stop-the-world",垃圾回收线程工作的时候，工作线程要暂停，直到垃圾收集工作结束)。
       * 按工作模式分：并发式垃圾回收器和独占式垃圾回收器。 
         * 并发垃圾回收器和应用程序交替工作
         * 垃圾回收器stop the world一旦执行，所有的用户线程必须暂停，等待垃圾回收线程工作完。
       * 按碎片处理方式分：可分为压缩式垃圾回收器和非压缩式垃圾回收器。

   45. 7款经典的收集器、与垃圾分代之间的关系：

       * Young Gen

         >Serial GC, Parallel Scavenge GC, ParNew GC

       * Old Gen

         >Serial Old GC, Parallel Old GC, CMS GC

       * 整堆收集器：G1

         ![image-20200713093757644](D:\Study Document\Java Learning\Java Notes\JVM\LearningNotes\JVM\1_内存与垃圾回收篇\17_垃圾回收器\images\image-20200713093757644.png)

   ### 04、框架

   1. Springboot相较于spring的优点：

   * 内嵌服务器
   * 自动starter依赖，简化构建配置
   * 自动配置spring和第三方共能
   * ...

   2. JDBC本质是一套接口：

   * 注册驱动 com.mysql.jdbc.driver
   * 获取连接 conn ,DriverManager.getConnection(url,user,password);
   * 获取数据库操作对象stat
   * 执行sql语句 executeQuery（DQL）, executeUpdate(DML)，返回数据库改变的受影响的记录条数
   * 处理查询结果集
   * 关闭资源， conn, stat

   ```java
   public void login(){
       Connection conn = null;
       Statement stat = null; 
       ResultSet rs = null; 
       try{
         Class.forName("com.mysql.jdbc.driver");
         conn = DriverManager.getConnection(url,user,password); 
   	  stat = conn.creatStatement();   
         string sql = "";
   	  rs = stat.executeQuery(sql);  
         while(rs.next()){
             
         }
       }catch(ClassNotFoundException e){
        	e.printStackTrace();   
       }finally{
           if(rs != null){
               try{
                   rs.close();
               }catch(){}
           }
           ..conn.. stat
       }
   }
   ```

4. <mark>sql注入：用户输入的信息中包含了sql语句的关键字，使原有的含义发生了改变。</mark> 例如：password = 'fsda' or '1' = '1'; or关键字，只要一边成立了，就成立了。根本原因是：关键字也参与了sql语句的编译过程。
5. 如何解决sql注入：让关键字不要参与sql的编译，prepareStatement-->让sql语句的框架先进行编译，然后再传值。ps.setString(1,username), select * from emp where username = ? and password = ?,第一个问号的下标是1。
6. JDBC是怎样提交事务的，默认机制是：每执行一条DML语句就会自动提交一次事务，但是在某些业务中，要求N条DML语句一起执行，一同失败。 关闭自动提交事务：conn.setAtuocommit(false); --> conn.commit();

### 05、 Web基础

1. Get请求：get请求会将请求所携带的参数作为URL的一部分出现，所以请求参数会显示在地址栏：

   * 请求参数只能是字符串
   * 可以携带的数据量小
   * 数据安全性低，直接在地址栏就可以看到请求参数

   >重要特征：客户端一旦接受到服务器向get请求发送的响应，浏览器会自动缓存响应，当客户再次惊进行相同请求的提交，将直接读取浏览器本地缓存中的响应数据，不再向服务器请求响应数据。

2. Post请求：POST请求所携带的数据会以请求正文的形式出现

   * 数据类型可以是任意类型，图片，视频
   * 请求可以携带的数据量大
   * 数据安全性高

   >Post请求的客户端浏览器不会对服务器向post请求发送的响应进行缓存，下次发送同样的post请求，还是直接向服务器请求

3. HTTP协议分为请求协议和响应协议：request请求分为：请求行，请求报头，空白行，请求正文。 响应协议：状态行，响应报头、空白行、响应正文。

4. 默认请求提交的方式：

   * 表单提交，默认get,可以指定post
   * AJAX请求，默认get,可以指定post
   * 地址栏请求，默认get
   * 超链接请求，默认get
   * src资源路径请求，默认get

5. Servlet的生命周期：1.实例化，2.初始化，3.服务service()，4.销毁destory()

   ![image-20220323105645333](https://gitee.com/light21/my-picture/raw/master/img/202203281034729.png)

   >Servlet的整个生命周期的执行，均有web服务器负责管理。服务器负责管理。即 Servlet 从创建到服务到销毁的整个过程中方法的调用，都是由 Web 服务器负责调用执行，程序员无法控制其过程。

6. url-pattern的几种模式：

   * 精确路径模式 <url-pattern>/some/hello</url-pattern>
   * 通配路径模式 <url-pattern>/some/*</url-pattern>
   * 全路径模式<url-pattern>/*</url-pattern>, <url-pattern>/</url-pattern>
     * /* 不管是动态请求，还是静态资源的请求，都会被拦截，用户都不会直接获得这些资源文件，都要通过当前Servelt来处理
     * / 只有静态资源才会被拦截，动态资源是不会被拦截的。用户请求的静态资源文件是不能直接获取到的。
   * 后缀名模式<url-pattern>/*.do</url-pattern>

   >精确路径优先匹配

7. http请求中出现的中文乱码问题：

   * Http协议的底层是TCP传输协议：是一种面对连接，可靠的，基于字节流的
   * Http协议规定，数据的传输采用字节编码的方式，即无论你浏览器提交的中文是什么字符编码格式，一旦由浏览器经过HTTP协议进行转发，则这些数据就是以字节的形式上传到服务器的。在请求中，这些字节均以%开头，并以十六进制形式出现。如 %5A%3D。
   * Tomcat 服务器在接收到这些字节后，并不知道它们原始采用的是什么字符编码。而Tomcat 默认的编码格式为 ISO8859-1 。所以会将这些字节按照 ISO8859-1的格式进行编码，编码后在控制台显示，所以在控制台会显示乱码。

8. 请求转发和请求重定向

   * 请求转发：资源内转发，用户提交的请求需要访问服务器内部的资源1，而资源1有需要访问资源2，整个过程中浏览器只发出一次请求，服务器只发出一次响应。整个过程中，只存在一次请求，即用户所提交的请求。所以，无论是资源 1 还是资源 2 ，它们均可从这个请求中获取到用户提交请求时所携带的相关数据。
   * 重定向：两次请求，两次响应。--》防止表单重复提交

9. URL+URI：可以分为资源路径+资源名称

   ![image-20220323164852152](C:\Users\Light\AppData\Roaming\Typora\typora-user-images\image-20220323164852152.png)

   根据“资源路径是否可以独立完成资源准确定位”的判别标准，可以将访问路径分为绝对路径与相对路径。

   * 绝对路径：绝对路径，是指根据给出的访问路径可以准确定位到资源的路径。而对于计算机中Web 应用的绝对路径，则是指带访问协议的路径 ，即 URL。
   * 相对路径：相对路径，是指仅根据访问路径无法准确定位资源的路径。相对路径必须要结合其参照路径才可组成可以准确定位资源的绝对路径。
     * 以路径名称开头的， 无论是前台还是后台，参照路径：<mark>当前访问路径的资源路径</mark>
     * 以/开头的：
       * 前台路径：例如html、css、js中的路径，以及jsp文件中的静态部分的路径。**参照路径：当前web服务器的根路径，即 http://127.0.0.1:8080 。**
       * 后台路径：所谓后台路径是指，由服务器解析执行的代码及文件中所包含的路径。例如， java 代码
         中的路径、 jsp 文件动态部分（java 代码块）中的路径、 xml 等配置文件中的路径。**参照路径：当前web应用的根路径。如 http://127.0.0.1:8080/primary 。**
         * <font color = red>特例：重定向的路径：当代码中使用 response 的 sendRedirect() 方法进
           行重定向时， 若其参照路径是以斜杠开头，则 其参照路径不是 web 应用的根路径，而是 web           服务器的根路径。</font>
   
10. **Cookie: 客户端中用来保存会话状态的资源**。会话：围绕一件相关事情所进行的请求和响应。在这些请求与响应之间一定是需要数据传递的，所以需要会话状态跟踪的。HTTP协议是一种无状态协议，在不同的请求之间，数据是无法传递的。

    * 用户第一次向服务器发送请求，服务端生成cookie,将其封装在响应报头中，发送给客户端。
    * 客户端接收到响应之后，会将cookie保存在客户端本地。
    * 当用户再次发送同类请求的，在同类请求的请求报头中会携带客户端的cookie数据，发送到服务端，这样就在两次请求中实现了会话跟踪。cookie是key, value的键值对。

11. **Session:服务器上用来保存会话状态的资源。**Session的工作原理：

    * 不同的会话对应不同的Session,如何识别同一个会话的Session
    * 当前应用的Session是以Map形式管理的，该Map称为Session列表，Map的key为32位的随机字符串，JsessionID, value为Session的引用。
    * 当用户第一次发送请求时，就生成session，并存在Session列表当中。之后还会将JSEESIONID作为name,32位的随机串作为value,以cookie的形式放在响应报头中，发送给客服端。
    * 客户端接收Cookie后将其缓存在浏览器当中。当用户发送同类请求的时候，会将cookie信息封装在请求的请求头中，发送给服务器，服务器得到整个jsseionID,就能找到在Session列表中找到对应的Session.

12. Cookie禁用后使用session进行会话跟踪。--》如何解决：URL的重写机制。

    * 手工重写URL，重写机制是指，将 JSessionID 添加到请求的最后。
    * 重定向URL重写：HttpServletResponse具有一个方法encodeRedirectURL(),会在重定向后的路径自动添加jsesionid; 

### 06、Java8新特性

1. 函数式接口： 存放该接口的包：java.util.function, 该包的所有接口都有@FunctionalInterface注解，提供函数式编程。
2. Lamda表达式：只要方法的参数时函数式接口，就可以使用Lambda表达式。

### 07、 计算机网络

1. **OSI 七层模型** 是国际标准化组织提出一个网络分层模型， 七层模型：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。

   ![img](https://gitee.com/light21/my-picture/raw/master/img/202203281542326.png)

2. 主要还是TCP/IP四层模型。<mark>1.应用层， 2.传输层， 3，网络层， 4， 网络接口层</mark>

   * 应用层：传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，定义了信息交换的格式，消息会交给下一层传输层来传输。应用层交互的数据单元称为：报文。
   * 传输层：负责向两台终端设备进程之间的通信提供通用的数据传输服务。应用进程利用该服务传输应用层报文。
     * TCP(传输控制协议)--》HTTP协议的底层就是TCP协议，TCP协议是一种面向连接的，可靠的数据传输服务。
     * UDP(用户数据协议)， 提供无连接，尽最大努力传输数据，是一种不可靠的数据传输
   * 网络层： 负责为分组交换网上的不同主机提供通信服务。在发送数据的时候，网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送。
   * 网络接口层: 可以看成是物理层和数据链路层的合体。
     * 链路层：将网络层交下来的IP数据包组装成帧，在两个相邻节点间的链路上传送帧。
     * 物理层：实现相邻计算机接待你之间比特流的透明传送。

3. HTTP通信过程的步骤：

   1. 服务器在 80 端口等待客户的请求。
   2. 浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。
   3. 服务器接收来自浏览器的 TCP 连接。
   4. 浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。
   5. 关闭 TCP 连接

4. 















